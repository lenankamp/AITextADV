<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4 Quadrants with Sidebar</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
        }
        .sidebar {
            width: 200px;
            background-color: #333;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: width 0.3s;
        }
        .sidebar.collapsed {
            width: 50px;
        }
        .content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 5px 1fr;
            gap: 0;
            padding: 10px;
        }
        .side {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .quadrant {
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ccc;
            position: relative;
            overflow: auto;
        }
        .toggle-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        .resizer {
            background-color: white;
            cursor: col-resize;
            width: 5px;
        }
        .resizer.horizontal {
            cursor: row-resize;
            height: 5px;
            width: 100%;
        }
        .output {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            height: calc(100% - 50px);
            max-height: calc(100% - 50px);
            top:0;
            box-sizing: border-box;
            overflow: auto; 
            position: absolute;
            top: 0;
            width: 100%; 
        }
        .input-container {
            display: flex;
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px; /* Set a fixed height for the input container */
        }
        .input-container input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
        }
        .input-container button {
            padding: 10px;
            background-color: #444;
            color: white;
            border: none;
            cursor: pointer;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
        }
        .settings-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80%;
            overflow-y: auto;
        }
        .settings-container label {
            display: block;
            margin-top: 10px;
        }
        .settings-container input,
        .settings-container textarea {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }
        .settings-container button {
            margin-top: 20px;
            padding: 10px;
            background-color: #444;
            color: white;
            border: none;
            cursor: pointer;
        }
        .image-grid {
            display: grid;
            gap: 10px;
            padding: 10px;
            height: 100%;
        }
        .image-grid img {
            width: 30%;
            object-fit: cover;
            border: 1px solid #ccc;
        }
        .image-row {
            display: flex;
            flex-flow: row wrap;
            gap: 10px; /* Optional: Add some space between the images */
        }
        .tooltip {
            position: absolute;
            width: 400px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px;
            border-radius: 5px;
            display: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        <button class="toggle-btn" onclick="toggleSidebar()">Toggle</button>
        <button class="toggle-btn" onclick="saveGame()">Save</button>
        <button class="toggle-btn" onclick="loadGame()">Load</button>
        <button class="toggle-btn" onclick="openSettings()">Settings</button>
        <input type="file" id="fileInput" style="display:none" onchange="loadFromFile(event)">
    </div>
    <div class="content">
        <div class="tooltip" id="tooltip"></div>
        <div class="side" id="left">
            <div class="quadrant" id="q1" style="height: 640px;">
                <div class="image-grid" id="imageGrid"></div>
            </div>
            <div class="resizer horizontal" id="resizer-row1"></div>
            <div class="quadrant" id="q3"  style="flex: 1;">Quadrant 3</div>
        </div>
        <div class="resizer" id="resizer-col"></div>
        <div class="side" id="right">
            <div class="quadrant" id="q2" style="height: 640px;"><img id="sceneart" style="height:100%"></div>
                        <div class="resizer horizontal" id="resizer-row2"></div>
            <div class="quadrant" id="q4" style="flex: 1;">
                <div class="output" id="output"></div>
                <div class="input-container">
                    <input type="text" id="input" placeholder="Type your message here..." onkeydown="handleKeyDown(event)">
                    <button onclick="sendMessage(input.value)">Send</button>
                </div>
            </div>
        </div>    
    </div>

    <div class="overlay" id="settingsOverlay">
        <div class="settings-container">
            <h2>Settings</h2>
            <form id="settingsForm"></form>
            <button type="button" onclick="saveSettings()">Save</button>
            <button type="button" onclick="closeSettings()">Cancel</button>
        </div>
    </div>

    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }

        const resizerCol = document.getElementById('resizer-col');
        const resizerRow1 = document.getElementById('resizer-row1');
        const resizerRow2 = document.getElementById('resizer-row2');
        const content = document.querySelector('.content');
        const leftSide = document.getElementById('left');
        const rightSide = document.getElementById('right');
        const quadrant1 = document.getElementById('q1');
        const quadrant2 = document.getElementById('q2');
        const quadrant3 = document.getElementById('q3');
        const quadrant4 = document.getElementById('q4');

        let startX, startY, startWidth, startHeight;

        resizerCol.addEventListener('mousedown', initDragCol);
        resizerRow1.addEventListener('mousedown', initDragRow);
        resizerRow2.addEventListener('mousedown', initDragRow);

        function initDragCol(e) {
            startX = e.clientX;
            startWidth = parseInt(document.defaultView.getComputedStyle(content).getPropertyValue('grid-template-columns').split(' ')[0]);
            document.addEventListener('mousemove', doDragCol, false);
            document.addEventListener('mouseup', stopDragCol, false);
        }

        function doDragCol(e) {
            const newWidth = startWidth + (e.clientX - startX);
            content.style.gridTemplateColumns = `${newWidth}px 5px 1fr`;
        }

        function stopDragCol() {
            document.removeEventListener('mousemove', doDragCol, false);
            document.removeEventListener('mouseup', stopDragCol, false);
        }

        function initDragRow(e) {
            startY = e.clientY;
            const quadrant = e.target.previousElementSibling;
            startHeight = parseInt(document.defaultView.getComputedStyle(quadrant).getPropertyValue('height'));
            document.addEventListener('mousemove', doDragRow, false);
            document.addEventListener('mouseup', stopDragRow, false);
            document.quadrant = quadrant; // Store the quadrant in the document object
        }

        function doDragRow(e) {
            const quadrant = document.quadrant; // Retrieve the quadrant from the document object
            const newHeight = startHeight + (e.clientY - startY);
            quadrant.style.height = `${newHeight}px`;
        }

        function stopDragRow() {
            document.removeEventListener('mousemove', doDragRow, false);
            document.removeEventListener('mouseup', stopDragRow, false);
            document.quadrant = null; // Clear the stored quadrant
        }

        // IndexedDB setup
        let db;
        const request = indexedDB.open('gameData', 1);

        request.onupgradeneeded = function(event) {
            db = event.target.result;
            const objectStore = db.createObjectStore('data', { keyPath: 'id' });
        };

        request.onsuccess = function(event) {
            db = event.target.result;
        };

        request.onerror = function(event) {
            console.error('Database error:', event.target.errorCode);
        };

        let settings;

        async function loadSettings() {
            const defaultSettings = {
                starting_area: "Home",
                starting_area_description: "A cozy and warm room within a wooden cabin, your bed sits in the corner. A fire crackles in the fireplace, casting flickering shadows on the walls. The smell of pine and woodsmoke fills the air.",
                sdAPI: "http://localhost:7860/sdapi/v1/txt2img",
                default_prompt: "__default__,",
                default_negative_prompt: "__defaultneg__,",
                sd_width: 768,
                sd_height: 1024,
                steps: 15,
                cfg_scale: 7,
                save_images: false,
                sampler_name: "Euler_a",
                seed_variation: 3,
                textAPI: "http://localhost:5001/api/v1/generate",
                max_context_length: 4096,
                max_length: 400,
                text_prompt: " <s> [INST] $system_prompt\n\n### INPUT\n$input_string [/INST]\n$response_string",
                stop_sequence: ["###", "<s>", " <s>", " <s> ", "### INPUT"],
                story_param: {
                    system_prompt: "Continue the story according to the bracketed instructions. Create a lifelike atmosphere with vivid, immersive details that draw the reader into the story. Use 2nd-person perspective, present tense, referring to the player as \"you\". Avoid vague statements, flowery metaphors, summaries, or send-off messages (do not end the scene). Focus on the moment, including visual and sensory detail, with quoted dialogue if appropriate. Be creative and don't always make events predictable. Characters should behave realistically and not always pander to the player. Write in the style of: Terry Pratchett.",
                    quiet: false,
                    rep_pen: 1.1,
                    rep_pen_range: 256,
                    rep_pen_slope: 1,
                    temperature: 1.0,
                    tfs: 1,
                    top_a: 0,
                    top_k: 100,
                    top_p: 0.9,
                    typical: 1
                },
                question_param: {
                    system_prompt: "Simply and clearly answer the question. Be as concise as possible.",
                    quiet: false,
                    rep_pen: 1.0,
                    rep_pen_range: 0,
                    rep_pen_slope: 1,
                    temperature: 0.01,
                    tfs: 1,
                    top_a: 0,
                    top_k: 100,
                    top_p: 0.9,
                    typical: 1
                }
            };

            try {
                const response = await fetch('settings.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const loadedSettings = await response.json();
                settings = { ...defaultSettings, ...loadedSettings[0] }; // Merge default and loaded settings
            } catch (error) {
                console.error('Failed to load settings:', error);
                settings = defaultSettings;
            }
        }

        async function generateText(params, input, post='') {
                // Send message to API
                const response = await fetch(settings.textAPI, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        max_context_length: settings.max_context_length,
                        max_length: settings.max_length,
                        prompt: settings.text_prompt
                                .replace('$system_prompt', params.system_prompt)
                                .replace('$input_string', input)
                                .replace('$response_string', post),
                        quiet: params.quiet,
                        rep_pen: params.rep_pen,
                        rep_pen_range: params.rep_pen_range,
                        rep_pen_slope: params.rep_pen_slope,
                        temperature: params.temperature,
                        tfs: params.tfs,
                        top_a: params.top_a,
                        top_k: params.top_k,
                        top_p: params.top_p,
                        typical: params.typical,
                        stop_sequence: settings.stop_sequence
                    })
                });

                const data = await response.json();
                return data.results[0].text;
        }
        
        async function generateArt(prompt, negprompt='', seed=-1) {
            let sum = 0;
            if (typeof seed == "string") {
                for (let i=0; i < seed.length; i++)
                    sum*= seed.charCodeAt(i);
            }
            else
                sum = seed;

            const response = await fetch(settings.sdAPI, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        "prompt": settings.default_prompt+prompt,
                        "negative_prompt": settings.default_negative_prompt+negprompt,
                        "width": settings.sd_width,
                        "height": settings.sd_height,
                        "steps": settings.steps,
                        "seed": sum+Math.floor(Math.random() * settings.seed_variation),
                        "cfg_scale": settings.cfg_scale,
                        "send_images": true,
                        "save_images": settings.save_images,
                        "sampler_name": settings.sampler_name

                    })
                });

                const data = await response.json();
                // Assuming the image data is in data.images[0] as a base64 string
                const imageBase64 = data.images[0];
                const binaryString = window.atob(imageBase64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);

                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Create a Blob from the array buffer
                const blob = new Blob([bytes], { type: 'image/png' });
                return blob;
        }

        function saveGame() {
            const transaction = db.transaction(['data'], 'readwrite');
            const objectStore = transaction.objectStore('data');
            const data = {
                id: 'gameState',
                state: {
                    // Add game state data here
                }
            };
            objectStore.put(data);
            saveToFile(data);
        }

        function loadGame() {
            const transaction = db.transaction(['data']);
            const objectStore = transaction.objectStore('data');
            const request = objectStore.get('gameState');

            request.onsuccess = function(event) {
                const data = event.target.result;
                if (data) {
                    // Load game state data here
                } else {
                    alert('No saved game found');
                }
            };
        }

        function saveToFile(data) {
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'gameState.json';
            a.click();
        }

        function loadFromFile(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = JSON.parse(e.target.result);
                const transaction = db.transaction(['data'], 'readwrite');
                const objectStore = transaction.objectStore('data');
                objectStore.put(data);
                // Load game state data here
            };
            reader.readAsText(file);
        }

        document.querySelector('.toggle-btn[onclick="loadGame()"]').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        async function sendMessage(message = input.value) {
            const input = document.getElementById('input');
            const output = document.getElementById('output');
            const messageElement = document.createElement('div');
            if (message.trim()) {
                messageElement.innerHTML = '\n[Generate the next two paragraphs as player attempts to ' + message + ']';
            } else {
                messageElement.innerHTML = '\n[Continue the story for another two paragraphs.]';
            }
            output.appendChild(messageElement);
            input.value = '';
            output.scrollTop = output.scrollHeight;

            const text = await generateText(settings.story_param, output.textContent);
            messageElement.innerHTML = "<br>" + text.replace(/\n/g, '<br>');
            output.scrollTop = output.scrollHeight;

            await outputCheck(text, output.textContent);

            // Await the result of generateArt
            const artPrompt = await generateText(settings.question_param, messageElement.innerHTML + '\n[How would you describe the visual details of the previous scene in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]');
            const blob = await generateArt(artPrompt);
            document.getElementById('sceneart').src = URL.createObjectURL(blob);
            document.getElementById('sceneart').alt = artPrompt;
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter') {
                sendMessage(input.value);
            }
        }

        function openSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const form = document.getElementById('settingsForm');
            form.innerHTML = ''; // Clear the form

            // Dynamically populate the form with current settings
            for (const key in settings) {
                if (settings.hasOwnProperty(key)) {
                    const value = settings[key];
                    const label = document.createElement('label');
                    label.textContent = key;
                    form.appendChild(label);

                    if (typeof value === 'object') {
                        const textarea = document.createElement('textarea');
                        textarea.id = key;
                        textarea.name = key;
                        textarea.value = JSON.stringify(value, null, 2);
                        form.appendChild(textarea);
                    } else {
                        const input = document.createElement('input');
                        input.type = typeof value === 'boolean' ? 'checkbox' : 'text';
                        input.id = key;
                        input.name = key;
                        if (typeof value === 'boolean') {
                            input.checked = value;
                        } else {
                            input.value = value;
                        }
                        form.appendChild(input);
                    }
                }
            }

            overlay.style.display = 'flex';
        }

        function closeSettings() {
            const overlay = document.getElementById('settingsOverlay');
            overlay.style.display = 'none';
        }

        function saveSettings() {
            const form = document.getElementById('settingsForm');
            console.log('Settings before save:', settings);
            // Update settings with form values
            for (const key in settings) {
                if (settings.hasOwnProperty(key)) {
                    const input = form.elements[key];
                    if (input) {
                        if (input.type === 'checkbox') {
                            settings[key] = input.checked;
                        } else if (input.tagName === 'TEXTAREA') {
                            settings[key] = JSON.parse(input.value);
                        } else {
                            if (!isNaN(input.value) && input.value.trim() !== '') {
                                settings[key] = parseInt(input.value);
                            } else {
                                settings[key] = input.value;
                            }
                        }
                    }
                }
            }

            closeSettings();
        }

        async function generateArea(areaName, prompt='') {
            areas[areaName].name = name;
            areas[areaName].seed = Math.floor(Math.random() * 4294967295) + 1;
            let response;
            if(prompt == '')
            {
                response = await generateText(settings.question_param, "[Generate a description of the area named " + areaName + ".]");
                areas[areaName].description = response;
            }
            else
            {
                areas[areaName].description = prompt;
            }
            response = await generateText(settings.question_param, "[Be creative and generate a list of people and interesting things that could reasonaly be found in the area named " + areaName + " with the following details: " + areas[areaName].description + " \nIf no people or hostiles might be reasonably found in the area, reply with None. Do not generate more than 4 in one category. Things must be solid physical interactable pieces of interest within the area. Descriptions should be 1-2 sentences. Answer in a formatted list as such: \nPeople\n- Name: Description\n...\nThings\n- Name: Description\n...\nHostiles\n- Name: Description\n...\n]");
            // Process response to get people, things, and hostiles into the area object as a subset for each type.
            const lines = response.split('\n');
            let currentSection = null;
            for (const line of lines) {
                if (line.startsWith('People')) {
                    currentSection = 'people';
                    areas[areaName][currentSection] = [];
                } else if (line.startsWith('Things')) {
                    currentSection = 'things';
                    areas[areaName][currentSection] = [];
                } else if (line.startsWith('Hostiles')) {
                    currentSection = 'hostiles';
                    areas[areaName][currentSection] = [];
                } else if (currentSection && line.trim() && !line.includes('None')) {
                    const [namePart, ...descriptionParts] = line.split(': ');
                    const name = namePart.replace(/[^a-zA-Z\s]/g, '').trim();
                    const description = descriptionParts.join(': ').trim();
                    let visual = await generateText(settings.question_param, "[How would you describe '" + name.replace('-', '') + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                    const seed = Math.floor(Math.random() * 4294967295) + 1;
                    let negprompt = "";
                    if(currentSection == "people")
                    {
                        negprompt = "";
                    }
                    else if(currentSection == "hostiles")
                    {
                        negprompt = "friendly";
                    }
                    else if(currentSection == "things")
                    {
                        negprompt = "((people, human, person))";
                        visual = "(("+ name.replace('-', '') + ")),(nopeople)" + visual;
                    }
                    const image = await generateArt(visual, negprompt, seed);
                    areas[areaName][currentSection].push({ name: name.replace('-', ''), description, visual, seed, image});
                }
            }
            
            areas[areaName].visual = await generateText(settings.question_param, areas[settings.starting_area].description + '\n[How would you describe the visual details of the previous scene in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]');
            areas[areaName].image = await generateArt(areas[areaName].visual, "people", areas[areaName].seed);
            updateImageGrid(areaName);
        }

        function updateImageGrid(areaName) {
            const imageGrid = document.getElementById('imageGrid');
            const tooltip = document.getElementById('tooltip');
            imageGrid.innerHTML = '';

            const categories = ['people', 'things', 'hostiles'];
            categories.forEach(category => {
            if (areas[areaName][category]) {
                const row = document.createElement('div');
                row.classList.add('image-row');
//                const title = document.createElement('h3');
//                title.textContent = category.charAt(0).toUpperCase() + category.slice(1);
//                row.appendChild(title);
                areas[areaName][category].forEach(item => {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(item.image);
                img.alt = item.name;
                img.addEventListener('mouseover', () => {
                    tooltip.style.display = 'block';
                    tooltip.innerHTML = `<strong>${item.name}</strong><br>${item.description}<br><img src="${img.src}" alt="${item.name}" style="width: 100px; height: auto;">`;
                });
                img.addEventListener('mousemove', (e) => {
                    tooltip.style.left = e.pageX + 10 + 'px';
                    tooltip.style.top = e.pageY + 10 + 'px';
                });
                img.addEventListener('mouseout', () => {
                    tooltip.style.display = 'none';
                });
                row.appendChild(img);
                });
                imageGrid.appendChild(row);
            }
            });
        }

        async function outputCheck(text, context="") {
            const response = await generateText(settings.question_param, areaContext(currentArea) + "\n\nContext:\n" + context + "\n\nPassage:\n" + text + "\n\n[Answer the following questions in a numbered list format in regard to the passage. If the question can not be answered just respond with 'N/A' and no explaination. 1. If a new person is in the scene, what is their name, or a simple two word description if name is not revealed? 2. If a new hostile is in the scene or someone in the scene has become hostile, what is their name, or a simple two word description if name is not revealed? 3. If the scene changed location, where is the scene now?" + "]");
            const lines = response.split('\n');
            for (const line of lines) {
                if (line.startsWith('1.') && !line.includes('N/A')) {
                    const names = line.replace("1. ", '').trim().split(',').map(name => name.trim());
                    for (const name of names) {
                        if (!areas[currentArea]['people'].some(person => person.name === name)) {
                            const description = await generateText(settings.question_param, areaContext(currentArea) + "\n\nContext:\n" + context +"\n" + text + "\n\n[Write a description of '" + name + "'. Write a 1-2 sentence physical description including style of dress and hair color and style, and a 1-2 sentence personality description. If there is not enough information in the context, be creative.]");
                            const visual = await generateText(settings.question_param, "[How would you describe '" + name + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                            const seed = Math.floor(Math.random() * 4294967295) + 1;
                            const image = await generateArt(visual, "", seed);
                            areas[currentArea]['people'].push({ name, description, visual, seed, image });
                        }
                    }
                } else if (line.startsWith('2.') && !line.includes('N/A')) {
                    const names = line.replace("2. ", '').trim().split(',').map(name => name.trim());
                    for (const name of names) {
                        if (!areas[currentArea]['people'].some(person => person.name === name)) {
                            const description = await generateText(settings.question_param, areaContext(currentArea) + "\n\nContext:\n" + context +"\n" + text + "\n\n[Write a description of '" + name + "'. Write a 1-2 sentence physical description including style of dress and hair color and style, and a 1-2 sentence personality description. If there is not enough information in the context, be creative.]");
                            const visual = await generateText(settings.question_param, "[How would you describe '" + name + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                            const seed = Math.floor(Math.random() * 4294967295) + 1;
                            const image = await generateArt(visual, "", seed);
                            areas[currentArea]['people'].push({ name, description, visual, seed, image });
                        }
                    }
                }else if (line.startsWith('3.') && !line.includes('N/A')) {
                    const prevArea = currentArea;
                    currentArea = line.replace("3. ", '').trim();
                    if(!(currentArea in areas)){
                        areas[currentArea] = {};
                        await generateArea(currentArea);
                    }
                    const peopleNames = areas[prevArea].people.map(person => person.name).join(', ');
                    const movingPeople = await generateText(settings.question_param, areaContext(prevArea) + "\n\nContext:\n" + context + "\n\nPassage:\n" + text + "\n\n[Answer the following question in a list format separate by '\n' in regard to the passage. If the question can not be answered just respond with 'N/A' and no explanation. Among " + peopleNames + ", who moved with the player?" + "]");
                    const movers = movingPeople.split('\n');
                    for (const mover of movers) {
                        if (line.trim() != "") {
                            const personIndex = areas[prevArea]['people'].findIndex(person => person.name === mover);
                            if (personIndex !== -1) {
                                const person = areas[prevArea]['people'].splice(personIndex, 1)[0];
                                areas[currentArea]['people'].push(person);
                            }
                        }
                    }
                }
            }
            
            updateImageGrid(currentArea);
        }

        function areaContext(area) {
            let context = areas[area].name + " : " + areas[area].description + "\n\n";
            if(areas[area].people)
            {
                context += "People nearby\n";
                for(let i = 0; i < areas[area].people.length; i++)
                {
                    context += areas[area].people[i].name + ": " + areas[area].people[i].description + "\n";
                }
                context += "\n";
            }
            if(areas[area].things)
            {
                context += "Things in area\n";
                for(let i = 0; i < areas[area].things.length; i++)
                {
                    context += areas[area].things[i].name + ": " + areas[area].things[i].description + "\n";
                }
                context += "\n";
            }
            if(areas[area].hostiles)
            {
                context += "Hostiles nearby\n";
                for(let i = 0; i < areas[area].hostiles.length; i++)
                {
                    context += areas[area].hostiles[i].name + ": " + areas[area].hostiles[i].description + "\n";
                }
                context += "\n";
            }
            return context;
        }

        async function setupStart() {
            await generateArea(settings.starting_area, settings.starting_area_description);
            document.getElementById('sceneart').src = URL.createObjectURL(areas[settings.starting_area].image);
            document.getElementById('sceneart').alt = areas[settings.starting_area].description;
            const responseElement = document.createElement('div');
            let text = await generateText(settings.story_param, "[Generate the beginning of the story as the player stands in an area described as " + areas[settings.starting_area].description + " Response should be less than 300 words.]");

            // Trim incomplete sentences from the end of the text
            const sentences = text.match(/[^.!?]+[.!?]+["']?/g);
            if (sentences && sentences.length > 1) {
                sentences.pop(); // Remove the last incomplete sentence
                text = sentences.join(' '); // Rejoin the sentences
            }

            responseElement.innerHTML = text.replace(/\n/g, '<br>');
            output.appendChild(responseElement);
            output.scrollTop = output.scrollHeight;                
            await outputCheck(text);
            updateImageGrid(settings.starting_area);
        }

        // Things are people, monsters, and interactables.
        // Should have name, seed, type, visual, description, level, affinity,
        // health, attack, defense, speed, magic, magic defense, skills, items, location, status effects

        let areas = {};
        let currentArea;
        loadSettings().then(() => {
            areas[settings.starting_area] = {};
            currentArea = settings.starting_area;
            setupStart();
        });

    </script>
</body>
</html>