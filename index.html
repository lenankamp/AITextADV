<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AITextADV</title>
    <style>
        body {
            display: flex;
            height: 100vh;
            margin: 0;
        }
        .sidebar {
            width: 250px;
            background-color: #333;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: width 0.3s;
            position: relative;
        }
        .sidebar.collapsed .toggle-btn:not(:first-child) {
            display: none; /* Hide all buttons besides the first (menu) button when collapsed */
        }
        .sidebar.collapsed {
            width: 50px;
        }
        .toggle-btn:first-child {
            position: absolute;
            bottom: 20px; /* Fixed vertical position relative to the bottom */
        }
        .content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 5px 1fr;
            gap: 0;
            padding: 0px;
            max-height: 100vh;
        }
        .side {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-height: 100vh;
            min-height: 100vh;
        }
        .quadrant {
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ccc;
            position: relative;
            overflow: auto;
        }
        .toggle-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        .resizer {
            background-color: white;
            cursor: col-resize;
            width: 5px;
            height: 100%;
        }
        .resizer.horizontal {
            cursor: row-resize;
            height: 5px;
            width: 100%;
        }
        .output {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            height: calc(100% - 50px);
            max-height: calc(100% - 50px);
            top:0;
            box-sizing: border-box;
            overflow: auto; 
            position: absolute;
            top: 0;
            width: 100%; 
        }
        .input-container {
            display: flex;
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px; /* Set a fixed height for the input container */
        }
        .input-container input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
        }
        .input-container button {
            padding: 10px;
            background-color: #444;
            color: white;
            border: none;
            cursor: pointer;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
        }
        .settings-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            max-height: 80%;
            overflow-y: auto;
        }
        .settings-container label {
            display: block;
            margin-top: 10px;
        }
        .settings-container input,
        .settings-container textarea {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }
        .settings-container button {
            margin-top: 20px;
            padding: 10px;
            background-color: #444;
            color: white;
            border: none;
            cursor: pointer;
        }
        .image-grid {
            display: grid;
            gap: 10px;
            padding: 10px;
            height: 100%;
        }
        .image-grid img {
            width: 30%;
            object-fit: cover;
            border: 1px solid #ccc;
        }
        .image-row {
            display: flex;
            flex-flow: row wrap;
            gap: 10px; /* Optional: Add some space between the images */
        }
        .tooltip {
            position: absolute;
            width: 400px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px;
            border-radius: 5px;
            display: none;
            z-index: 10;
        }
        #playerart {
            height: 100%;
            display: flex;
            object-fit: cover;
            flex-grow: 1;
        }

        .progress {
            background-color: grey;
            width: 100%;
        }

        .loader {
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .map-container {
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .map {
            width: 2000px; /* Arbitrary large size for the map */
            height: 2000px;
            position: absolute;
            cursor: grab;
        }

        .map img {
            width: 100%;
            height: 100%;
            pointer-events: none; /* Disable default click and drag behavior */
        }

        .location {
            position: absolute;
            background-color: red;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
        }

        .submenu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="sidebar collapsed" id="sidebar">
        <button class="toggle-btn" onclick="toggleSidebar()">Menu</button>
        <button class="toggle-btn" onclick="saveGame()">Save</button>
        <button class="toggle-btn" onclick="document.getElementById('fileInput').click()">Load</button>
        <button class="toggle-btn" onclick="openSettings()">Settings</button>
        <button class="toggle-btn" onclick="restartGame()">Restart</button>
        <input type="file" id="fileInput" style="display:none">
    </div>
    <div class="content">
        <div class="tooltip" id="tooltip"></div>
        <div class="side" id="left">
            <div class="quadrant" id="q1" style="height: 640px;">
                <div class="image-grid" id="imageGrid"></div>
            </div>
            <div class="resizer horizontal" id="resizer-row1"></div>
            <div class="quadrant" id="q3" style="display: flex; flex-flow: row; justify-content: flex-start;">
            <img id="playerart">
            <div style="display: flex; flex-direction: column; gap: 10px; align-items: center; justify-content: flex-start; flex-grow: 1;">
                <progress id="health" value="100" max="100" style="accent-color: red;"></progress>
                <progress id="mana" value="100" max="100" style="accent-color: blue;"></progress>
                <progress id="exp" value="100" max="100" style="accent-color: green;"></progress>
                <progress id="level" value="100" max="100" style="accent-color: yellow;"></progress>
                <progress id="gold" value="100" max="100"></progress>
            </div>
            </div>
        </div>
        <div class="resizer" id="resizer-col"></div>
        <div class="side" id="right">
            <div class="quadrant" id="q2" style="height: 640px; display: flex; overflow:hidden;">
                <div class="map-container" style="width: 40%;">
                    <div class="map" id="map">
                        <img src="map.jpg" alt="Map">
                    </div>
                </div>
                <div class="resizer" id="resizer-map"></div>
                <div class="sceneart-container" style="width: 60%; height: 100%;">
                    <img id="sceneart" style="height:100%; width: 100%; object-fit: cover;">
                </div>
            </div>
            <div class="resizer horizontal" id="resizer-row2"></div>
            <div class="quadrant" id="q4" style="flex: 1;">
                <div class="output" id="output"></div>
                <div class="input-container">
                    <button onclick="undoLastAction()">Undo</button>
                    <input type="text" id="input" placeholder="Type your message here..." onkeydown="handleKeyDown(event)">
                    <button onclick="sendMessage(input.value)">Send</button>
                </div>
            </div>
        </div>    
    </div>

    <div class="overlay" id="settingsOverlay">
        <div class="settings-container">
            <h2>Settings</h2>
            <form id="settingsForm"></form>
            <button type="button" onclick="saveSettings()">Save</button>
            <button type="button" onclick="closeSettings()">Cancel</button>
        </div>
    </div>

    <div class="loader" id="loader" style="display: none;"></div>

    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
        }

        const resizerCol = document.getElementById('resizer-col');
        const resizerRow1 = document.getElementById('resizer-row1');
        const resizerRow2 = document.getElementById('resizer-row2');   
        const resizerMap = document.getElementById('resizer-map');
        const content = document.querySelector('.content');
        const leftSide = document.getElementById('left');
        const rightSide = document.getElementById('right');
        const quadrant1 = document.getElementById('q1');
        const quadrant2 = document.getElementById('q2');
        const quadrant3 = document.getElementById('q3');
        const quadrant4 = document.getElementById('q4');
        const map = document.getElementById('map');
        const mapContainer = document.querySelector('.map-container');
        const sceneartContainer = document.querySelector('.sceneart-container');
        const submenu = document.createElement('div');
        submenu.classList.add('submenu');
        document.body.appendChild(submenu);

        let startX, startY, startWidth, startHeight;

        resizerCol.addEventListener('mousedown', initDragCol);
        resizerRow1.addEventListener('mousedown', initDragRow);
        resizerRow2.addEventListener('mousedown', initDragRow);
        resizerMap.addEventListener('mousedown', initDragMap);

        function initDragCol(e) {
            startX = e.clientX;
            startWidth = parseInt(document.defaultView.getComputedStyle(content).getPropertyValue('grid-template-columns').split(' ')[0]);
            document.addEventListener('mousemove', doDragCol, false);
            document.addEventListener('mouseup', stopDragCol, false);
        }

        function doDragCol(e) {
            const newWidth = startWidth + (e.clientX - startX);
            content.style.gridTemplateColumns = `${newWidth}px 5px 1fr`;
        }

        function stopDragCol() {
            document.removeEventListener('mousemove', doDragCol, false);
            document.removeEventListener('mouseup', stopDragCol, false);
        }

        function initDragRow(e) {
            startY = e.clientY;
            const quadrant = e.target.previousElementSibling;
            startHeight = parseInt(document.defaultView.getComputedStyle(quadrant).getPropertyValue('height'));
            document.addEventListener('mousemove', doDragRow, false);
            document.addEventListener('mouseup', stopDragRow, false);
            document.quadrant = quadrant; // Store the quadrant in the document object
        }

        function doDragRow(e) {
            const quadrant = document.quadrant; // Retrieve the quadrant from the document object
            const newHeight = startHeight + (e.clientY - startY);
            quadrant.style.height = `${newHeight}px`;

            // Adjust the height of the quadrant below
            const nextQuadrant = quadrant.nextElementSibling.nextElementSibling;
            if (nextQuadrant && nextQuadrant.classList.contains('quadrant')) {
            nextQuadrant.style.height = `calc(100vh - ${newHeight}px - 5px)`; // 5px for the resizer
            }
        }

        function stopDragRow() {
            document.removeEventListener('mousemove', doDragRow, false);
            document.removeEventListener('mouseup', stopDragRow, false);
            document.quadrant = null; // Clear the stored quadrant
        }

        function initDragMap(e) {
            startX = e.clientX;
            startWidth = parseInt(document.defaultView.getComputedStyle(mapContainer).getPropertyValue('width'));
            document.addEventListener('mousemove', doDragMap, false);
            document.addEventListener('mouseup', stopDragMap, false);
        }

        function doDragMap(e) {
            const newWidth = startWidth + (e.clientX - startX);
            mapContainer.style.width = `${newWidth}px`;
            sceneartContainer.style.width = `calc(100% - ${newWidth}px - 5px)`; // 5px for the resizer
        }

        function stopDragMap() {
            document.removeEventListener('mousemove', doDragMap, false);
            document.removeEventListener('mouseup', stopDragMap, false);
        }

        // IndexedDB setup
        let db;
        const request = indexedDB.open('gameData', 1);

        request.onupgradeneeded = function(event) {
            db = event.target.result;
            const objectStore = db.createObjectStore('data', { keyPath: 'id' });
        };

        request.onsuccess = function(event) {
            db = event.target.result;
        };

        request.onerror = function(event) {
            console.error('Database error:', event.target.errorCode);
        };

        let settings;

        async function loadSettings() {
            const defaultSettings = {
                world_description: "A vast and mysterious world filled with magic and wonder.",
                player_name: "Adventurer",
                player_description: "A brave and adventurous soul, ready to explore the unknown.",
                player_visual: "A young adult with a determined expression, wearing a simple tunic and trousers.",
                player_seed: 1,
                starting_area: "Home",
                starting_area_description: "A cozy and warm room within a wooden cabin, your bed sits in the corner. A fire crackles in the fireplace, casting flickering shadows on the walls. The smell of pine and woodsmoke fills the air.",
                q1_height: "600px",
                q2_height: "640px",
                column_width: "640px",
                sdAPI: "http://localhost:7860/sdapi/v1/txt2img",
                default_prompt: "__default__,",
                default_negative_prompt: "__defaultneg__,",
                sd_width: 768,
                sd_height: 1024,
                steps: 15,
                cfg_scale: 7,
                save_images: false,
                sampler_name: "Euler_a",
                seed_variation: 3,
                full_context: "$world $player $locale $fullstory",
                story_param: {
                    textAPI: "http://localhost:5001/v1/",
                    textAPItype: "openai",       // currently supporting koboldcpp and openai for lm studio
                    model: "mistral-small-24b-instruct-2501-abliterated-i1",
                    max_context_length: 4096,
                    max_length: 400,
                    text_prompt: " <s> [INST] $system_prompt\n\n### INPUT\n$input_string [/INST]\n$response_string",
                    stop_sequence: ["###", "<s>", " <s>", " <s> ", "### INPUT"],
                    system_prompt: "Continue the story according to the bracketed instructions. Create a lifelike atmosphere with vivid, immersive details that draw the reader into the story. Use 2nd-person perspective, present tense, referring to the player as \"you\". Avoid vague statements, flowery metaphors, summaries, or send-off messages (do not end the scene). Focus on the moment, including visual and sensory detail, with quoted dialogue if appropriate. Be creative and don't always make events predictable. Characters should behave realistically and not always pander to the player. Write in the style of: Terry Pratchett.",
                    quiet: false,
                    rep_pen: 1.1,
                    rep_pen_range: 256,
                    rep_pen_slope: 1,
                    temperature: 1.0,
                    tfs: 1,
                    top_a: 0,
                    top_k: 100,
                    top_p: 0.9,
                    typical: 1
                },
                question_param: {
                    textAPI: "http://localhost:5001/v1/",
                    textAPItype: "openai",
                    model: "mistral-small-24b-instruct-2501-abliterated-i1",
                    max_context_length: 4096,
                    max_length: 400,
                    text_prompt: " <s> [INST] $system_prompt\n\n### INPUT\n$input_string [/INST]\n$response_string",
                    stop_sequence: ["###", "<s>", " <s>", " <s> ", "### INPUT"],
                    system_prompt: "Simply and clearly answer the question. Be as concise as possible.",
                    quiet: false,
                    rep_pen: 1.0,
                    rep_pen_range: 0,
                    rep_pen_slope: 1,
                    temperature: 0.01,
                    tfs: 1,
                    top_a: 0,
                    top_k: 100,
                    top_p: 0.9,
                    typical: 1
                }
            };

            /* disabled during testing, CORS issues with local file access
            try {
                const response = await fetch('settings.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const loadedSettings = await response.json();
                settings = { ...defaultSettings, ...loadedSettings[0] }; // Merge default and loaded settings
            } catch (error) {
                console.error('Failed to load settings:', error);
                settings = defaultSettings;
            }
            line below is the temporary workaround*/
            settings = defaultSettings;

            // Apply settings to elements
            document.getElementById('q3').style.height = `calc(100vh - ${settings.q1_height} - 5px)`;
            document.getElementById('q4').style.height = `calc(100vh - ${settings.q2_height} - 5px)`;
            document.getElementById('q1').style.height = settings.q1_height;
            document.getElementById('q2').style.height = settings.q2_height;
            content.style.gridTemplateColumns = `${settings.column_width} 5px 1fr`;
        }

        async function generateText(params, input, post='') {
                // Show loader
                document.getElementById('loader').style.display = 'block';

                let response;
                // Send message to API
                if(params.textAPItype == 'openai') {
                    response = await fetch(params.textAPI + 'chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            //'Authorization': 'Bearer ' + params.openai_key
                        },
                        body: JSON.stringify({
                            model: params.model,
                            messages: [
                            {
                                "role": "system",
                                "content": params.system_prompt
                            },
                            {
                                "role": "user",
                                "content": input
                            }
                            ],
                            max_completion_tokens: params.max_length,
                            temperature: params.temperature,
                            top_p: params.top_p,
                            n: 1,
                            stream: false,
                            stop: params.stop_sequence
                        })
                    });
                } else { // default to koboldcpp
                    response = await fetch(params.textAPI + 'generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            max_context_length: params.max_context_length,
                            max_length: params.max_length,
                            prompt: params.text_prompt
                                    .replace('$system_prompt', params.system_prompt)
                                    .replace('$input_string', input)
                                    .replace('$response_string', post),
                            quiet: params.quiet,
                            rep_pen: params.rep_pen,
                            rep_pen_range: params.rep_pen_range,
                            rep_pen_slope: params.rep_pen_slope,
                            temperature: params.temperature,
                            tfs: params.tfs,
                            top_a: params.top_a,
                            top_k: params.top_k,
                            top_p: params.top_p,
                            typical: params.typical,
                            stop_sequence: params.stop_sequence
                        })
                    });
                }
                

                const data = await response.json();

                // Hide loader
                document.getElementById('loader').style.display = 'none';

                if(params.textAPItype == 'openai') {
                    return data.choices[0].message.content;
                } else {
                    return data.results[0].text;
                }
        }
        
        async function generateArt(prompt, negprompt='', seed=-1) {
            // Show loader
            document.getElementById('loader').style.display = 'block';

            let sum = 0;
            if (typeof seed == "string") {
                for (let i=0; i < seed.length; i++)
                    sum*= seed.charCodeAt(i);
            }
            else
                sum = seed;

            const response = await fetch(settings.sdAPI, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        "prompt": settings.default_prompt+prompt,
                        "negative_prompt": settings.default_negative_prompt+negprompt,
                        "width": settings.sd_width,
                        "height": settings.sd_height,
                        "steps": settings.steps,
                        "seed": sum+Math.floor(Math.random() * settings.seed_variation),
                        "cfg_scale": settings.cfg_scale,
                        "send_images": true,
                        "save_images": settings.save_images,
                        "sampler_name": settings.sampler_name

                    })
                });

                const data = await response.json();
                // Assuming the image data is in data.images[0] as a base64 string
                const imageBase64 = data.images[0];
                const binaryString = window.atob(imageBase64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);

                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                const pngBlob = new Blob([bytes], { type: 'image/png' });

                // Converting PNG to WebP for file size reduction, shoud make quality or even this feature options

                const img = new Image();

                // Create a canvas element to draw the image
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");

                if (!ctx) {
                    throw new Error("Unable to obtain 2D rendering context.");
                }

                img.src = URL.createObjectURL(pngBlob);
                await new Promise((resolve) => {
                    img.onload = () => resolve();
                });

                canvas.width = img.width;
                canvas.height = img.height;

                ctx.drawImage(img, 0, 0);

                const webpBlob = await new Promise((resolve) => {
                    canvas.toBlob(
                        (blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                throw new Error("Failed to convert to WebP format.");
                            }
                        },
                        "image/webp",
                        .6   // quality 0-1, 1 being best quality
                    );
                });

                // Hide loader
                document.getElementById('loader').style.display = 'none';

                return webpBlob;
        }

        async function saveGame() {
            const transaction = db.transaction(['data'], 'readwrite');
            const objectStore = transaction.objectStore('data');
            const data = {
                id: 'gameState',
                state: {
                    areas: areas,
                    currentArea: currentArea,
                    outputLog: document.getElementById('output').innerHTML,
                    settings: settings
                }
            };
            objectStore.put(data);
            await saveToFile(data);
        }

        async function saveToFile(data) {
            const images = {};
            for (const area in areas) {
                if (areas[area].image) {
                    images[area] = areas[area].image;
                    areas[area].image = null;
                }
                for (const category of ['people', 'things', 'hostiles']) {
                    if (areas[area][category]) {
                        areas[area][category].forEach(item => {
                            if (item.image) {
                                images[item.name] = item.image;
                                item.image = null;
                            }
                        });
                    }
                }
            }

            const imagePromises = Object.keys(images).map(async key => {
                const imageBlob = images[key];
                const reader = new FileReader();
                return new Promise(resolve => {
                    reader.onloadend = () => {
                        images[key] = reader.result;
                        resolve();
                    };
                    reader.readAsDataURL(imageBlob);
                });
            });

            await Promise.all(imagePromises);

            const playerImageBlob = await fetch(document.getElementById('playerart').src).then(res => res.blob());
            const playerImageReader = new FileReader();
            const playerImagePromise = new Promise(resolve => {
                playerImageReader.onloadend = () => {
                    images['player'] = playerImageReader.result;
                    resolve();
                };
                playerImageReader.readAsDataURL(playerImageBlob);
            });

            await playerImagePromise;

            const blob = new Blob([JSON.stringify({ data, images })], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'gameState.json';
            a.click();

            const areaPromises = Object.keys(areas).map(async area => {
                if (images[area]) {
                    areas[area].image = await fetchImage(images[area]);
                }
                const categoryPromises = ['people', 'things', 'hostiles'].map(async category => {
                    if (areas[area][category]) {
                        const itemPromises = areas[area][category].map(async item => {
                            if (images[item.name]) {
                                item.image = await fetchImage(images[item.name]);
                            }
                        });
                        await Promise.all(itemPromises);
                    }
                });
                await Promise.all(categoryPromises);
            });
            await Promise.all(areaPromises);
        }

        async function loadFromFile(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const { data, images } = JSON.parse(e.target.result);
                    const transaction = db.transaction(['data'], 'readwrite');
                    const objectStore = transaction.objectStore('data');
                    objectStore.put(data);
                    areas = data.state.areas;
                    currentArea = data.state.currentArea;
                    document.getElementById('output').innerHTML = data.state.outputLog;
                    settings = data.state.settings;

                    const imagePromises = [];

                    for (const area in areas) {
                        if (images[area]) {
                            imagePromises.push(fetchImage(images[area]).then(blob => {
                                areas[area].image = blob;
                            }));
                        }
                        for (const category of ['people', 'things', 'hostiles']) {
                            if (areas[area][category]) {
                                areas[area][category].forEach(item => {
                                    if (images[item.name]) {
                                        imagePromises.push(fetchImage(images[item.name]).then(blob => {
                                            item.image = blob;
                                        }));
                                    }
                                });
                            }
                        }
                    }

                    await Promise.all(imagePromises);

                    document.getElementById('q1').style.height = settings.q1_height;
                    document.getElementById('q2').style.height = settings.q2_height;
                    content.style.gridTemplateColumns = `${settings.column_width} 5px 1fr`;

                    updateImageGrid(currentArea);
                    document.getElementById('sceneart').src = URL.createObjectURL(areas[currentArea].image);
                    document.getElementById('sceneart').alt = areas[currentArea].description;

                    if (images['player']) {
                        const playerImageBlob = await fetchImage(images['player']);
                        document.getElementById('playerart').src = URL.createObjectURL(playerImageBlob);
                    }
                };
                reader.readAsText(file);
            }
        }

        async function loadImages() {
            for (const area in areas) {
                if (areas[area].image) {
                    areas[area].image = await fetchImage(areas[area].image);
                }
                for (const category of ['people', 'things', 'hostiles']) {
                    if (areas[area][category]) {
                        for (const item of areas[area][category]) {
                            if (item.image) {
                                item.image = await fetchImage(item.image);
                            }
                        }
                    }
                }
            }
        }

        function fullContext() {
            return settings.full_context
                .replace('$world', settings.world_description)
                .replace('$player', "\nPlayer Name: " + settings.player_name + "\n" + settings.player_description)
                .replace('$locale', areaContext(currentArea))
                .replace('$fullstory', document.getElementById('output').innerHTML);
        }

        async function fetchImage(imageData) {
            const response = await fetch(imageData);
            const blob = await response.blob();
            return blob;
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            document.getElementById('fileInput').addEventListener('change', loadFromFile);
        });
        async function sendMessage(message = input.value) {
            const input = document.getElementById('input');
            const output = document.getElementById('output');
            const messageElement = document.createElement('div');
            if (message.trim()) {
                messageElement.innerHTML = '\n[Generate the next two paragraphs as player attempts to ' + message + ']';
            } else {
                messageElement.innerHTML = '\n[Continue the story for another two paragraphs.]';
            }
            output.appendChild(messageElement);
            input.value = '';
            output.scrollTop = output.scrollHeight;

            const text = await generateText(settings.story_param, fullContext() + messageElement.innerHTML);
            messageElement.innerHTML = "<br>" + text.replace(/\n/g, '<br>');
            output.scrollTop = output.scrollHeight;

            await outputCheck(text, output.textContent);

            // Await the result of generateArt
            const artPrompt = await generateText(settings.question_param, messageElement.innerHTML + '\n[How would you describe the visual details of the previous scene in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]');
            const blob = await generateArt(artPrompt);
            document.getElementById('sceneart').src = URL.createObjectURL(blob);
            document.getElementById('sceneart').alt = artPrompt;
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter') {
                sendMessage(input.value);
            } else if (event.ctrlKey && event.key === 'z') {
                undoLastAction();
            }
        }

        function undoLastAction() {
            const output = document.getElementById('output');
            if (output.lastChild) {
                output.removeChild(output.lastChild);
            }
        }

        function openSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const form = document.getElementById('settingsForm');
            form.innerHTML = ''; // Clear the form

            // Dynamically populate the form with current settings
            for (const key in settings) {
                if (settings.hasOwnProperty(key)) {
                    const value = settings[key];
                    const label = document.createElement('label');
                    label.textContent = key;
                    form.appendChild(label);

                    if (typeof value === 'object') {
                        const textarea = document.createElement('textarea');
                        textarea.id = key;
                        textarea.name = key;
                        textarea.value = JSON.stringify(value, null, 2);
                        form.appendChild(textarea);
                    } else {
                        const input = document.createElement('input');
                        input.type = typeof value === 'boolean' ? 'checkbox' : 'text';
                        input.id = key;
                        input.name = key;
                        if (typeof value === 'boolean') {
                            input.checked = value;
                        } else {
                            if (typeof value === 'string') {
                                input.value = value.replace(/\n/g, '\\n');
                            } else {
                                input.value = value;
                            }
                        }
                        form.appendChild(input);
                    }
                }
            }

            overlay.style.display = 'flex';
        }

        function closeSettings() {
            const overlay = document.getElementById('settingsOverlay');
            overlay.style.display = 'none';
        }

        function saveSettings() {
            const form = document.getElementById('settingsForm');
            // Update settings with form values
            for (const key in settings) {
                if (settings.hasOwnProperty(key)) {
                    const input = form.elements[key];
                    if (input) {
                        if (input.type === 'checkbox') {
                            settings[key] = input.checked;
                        } else if (input.tagName === 'TEXTAREA') {
                            settings[key] = JSON.parse(input.value);
                        } else {
                            if (!isNaN(input.value) && input.value.trim() !== '') {
                                settings[key] = parseInt(input.value);
                            } else {
                                settings[key] = input.value.replace(/\\n/g, '\n');
                            }
                        }
                    }
                }
            }
            document.getElementById('q1').style.height = settings.q1_height;
            document.getElementById('q2').style.height = settings.q2_height;
            content.style.gridTemplateColumns = `${settings.column_width} 5px 1fr`;
            closeSettings();
        }

        async function generateArea(areaName, prompt='') {
            areas[areaName].name = areaName;
            areas[areaName].seed = Math.floor(Math.random() * 4294967295) + 1;
            areas[areaName]['people'] = [];
            areas[areaName]['things'] = [];
            areas[areaName]['hostiles'] = [];

            let response;
            if (prompt == '') {
                response = await generateText(settings.question_param, settings.world_description + "\n[Generate a description of the area named " + areaName + ".]");
                areas[areaName].description = response;
            } else {
                areas[areaName].description = prompt;
            }
            response = await generateText(settings.question_param, settings.world_description + "\n[Be creative and generate a list of people and interesting things that could reasonably be found in the area named " + areaName + " with the following details: " + areas[areaName].description + " \nIf no people or hostiles might be reasonably found in the area, reply with None. Do not generate more than 4 in one category. Things must be non-living solid physical interactable pieces of interest within the area. Descriptions should be 1-2 sentences. Answer in a formatted list as such: \nPeople\n- Name: Description\n...\nThings\n- Name: Description\n...\nHostiles\n- Name: Description\n...\n]");

            // Process response to get people, things, and hostiles into the area object as a subset for each type.
            const lines = response.split('\n');
            let currentSection = null;
            const artPromises = [];
            for (const line of lines) {
                if (line.startsWith('People')) {
                    currentSection = 'people';
                } else if (line.startsWith('Things')) {
                    currentSection = 'things';
                } else if (line.startsWith('Hostiles')) {
                    currentSection = 'hostiles';
                } else if (currentSection && line.trim() && !line.includes('None')) {
                    const [namePart, ...descriptionParts] = line.split(': ');
                    const name = namePart.replace(/[^a-zA-Z\s]/g, '').trim();
                    const description = descriptionParts.join(': ').trim();
                    let visual = await generateText(settings.question_param, settings.world_description + "\n[How would you describe '" + name.replace('-', '') + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                    const seed = Math.floor(Math.random() * 4294967295) + 1;
                    let negprompt = "";
                    if (currentSection == "people") {
                        negprompt = "";
                    } else if (currentSection == "hostiles") {
                        negprompt = "friendly";
                    } else if (currentSection == "things") {
                        negprompt = "((people, human, person))";
                        visual = "((" + name.replace('-', '') + ")),(nopeople)" + visual;
                    }
                    const section = currentSection; // Capture the current section
                    artPromises.push(generateArt(visual, negprompt, seed).then(image => {
                        areas[areaName][section].push({ name: name.replace('-', ''), description, visual, seed, image });
                    }));
                }
            }
            areas[areaName].visual = await generateText(settings.question_param, settings.world_description + "\n" + areas[settings.starting_area].description + '\n[How would you describe the visual details of the area described in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]');

            artPromises.push(generateArt(areas[areaName].visual, "people", areas[areaName].seed).then(image => {
                areas[areaName].image = image;
            }));

            await Promise.all(artPromises);
        }

        function updateImageGrid(areaName) {
            const imageGrid = document.getElementById('imageGrid');
            const tooltip = document.getElementById('tooltip');
            imageGrid.innerHTML = '';

            const categories = ['people', 'things', 'hostiles'];
            categories.forEach(category => {
                if (areas[areaName][category]) {
                    const row = document.createElement('div');
                    row.classList.add('image-row');
                    areas[areaName][category].forEach(item => {
                        const img = document.createElement('img');
                        if (item.image instanceof Blob) {
                            img.src = URL.createObjectURL(item.image);
                        } else {
                            console.error('Invalid image Blob:', areaName, category, item.name, item.image);
                        }
                        img.alt = item.name;
                        img.addEventListener('mouseover', () => {
                            tooltip.style.display = 'block';
                            tooltip.innerHTML = `<strong>${item.name}</strong><br>${item.description}<br><img src="${img.src}" alt="${item.name}" style="width: 100px; height: auto;">`;
                        });
                        img.addEventListener('mousemove', (e) => {
                            tooltip.style.left = e.pageX + 10 + 'px';
                            tooltip.style.top = e.pageY + 10 + 'px';
                        });
                        img.addEventListener('mouseout', () => {
                            tooltip.style.display = 'none';
                        });
                        row.appendChild(img);
                    });
                    imageGrid.appendChild(row);
                }
            });
        }

        async function outputCheck(text, context="") {
            const response = await generateText(settings.question_param, settings.world_description + "\n" + areaContext(currentArea) + "\n\nContext:\n" + context + "\n\nPassage:\n" + text + "\n\n[Answer the following questions in a numbered list format in regard to the passage. If the question can not be answered just respond with 'N/A' and no explaination. 1. If a new person is in the scene, what is their name, or a simple two word description if name is not revealed? 2. If a new hostile is in the scene or someone in the scene has become hostile, what is their name, or a simple two word description if name is not revealed? 3. If the scene changed location, where is the scene now?" + "]");
            const lines = response.split('\n');
            for (const line of lines) {
                if (line.startsWith('1.') && !line.includes('N/A')) {
                    const names = line.replace("1. ", '').trim().split(',').map(name => name.trim());
                    for (const name of names) {
                        if (!areas[currentArea]['people'].some(person => person.name === name)) {
                            const description = await generateText(settings.question_param, settings.world_description + "\n" + areaContext(currentArea) + "\n\nContext:\n" + context +"\n" + text + "\n\n[Write a description of '" + name + "'. Write a 1-2 sentence physical description including style of dress and hair color and style, and a 1-2 sentence personality description. If there is not enough information in the context, be creative.]");
                            const visual = await generateText(settings.question_param, settings.world_description + "\n" + "[How would you describe '" + name + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                            const seed = Math.floor(Math.random() * 4294967295) + 1;
                            const image = await generateArt(visual, "", seed);
                            areas[currentArea]['people'].push({ name, description, visual, seed, image });
                        }
                    }
                } else if (line.startsWith('2.') && !line.includes('N/A')) {
                    const names = line.replace("2. ", '').trim().split(',').map(name => name.trim());
                    for (const name of names) {
                        if (!areas[currentArea]['people'].some(person => person.name === name)) {
                            const description = await generateText(settings.question_param, settings.world_description + "\n" + areaContext(currentArea) + "\n\nContext:\n" + context +"\n" + text + "\n\n[Write a description of '" + name + "'. Write a 1-2 sentence physical description including style of dress and hair color and style, and a 1-2 sentence personality description. If there is not enough information in the context, be creative.]");
                            const visual = await generateText(settings.question_param, settings.world_description + "\n" + "[How would you describe '" + name + "' described as '" + description + "' in a comma separated list ordered from most important details to least without specifying names for an AI image generation model?]");
                            const seed = Math.floor(Math.random() * 4294967295) + 1;
                            const image = await generateArt(visual, "", seed);
                            areas[currentArea]['people'].push({ name, description, visual, seed, image });
                        }
                    }
                }else if (line.startsWith('3.') && !line.includes('N/A')) {
                    const prevArea = currentArea;
                    currentArea = line.replace("3. ", '').trim();
                    if(!(currentArea in areas)){
                        areas[currentArea] = {};
                        await generateArea(currentArea);
                    }
                    if(areas[prevArea].people.length > 0)
                    {
                        const peopleNames = areas[prevArea].people.map(person => person.name).join(', ');
                        const movingPeople = await generateText(settings.question_param, settings.world_description + "\n" + areaContext(prevArea) + "\n\nContext:\n" + context + "\n\nPassage:\n" + text + "\n\n[Answer the following question in a list format separate by '\n' in regard to the passage. If the question can not be answered just respond with 'N/A' and no explanation. Among " + peopleNames + ", who moved with the player?" + "]");
                        const movers = movingPeople.split('\n');
                        for (const mover of movers) {
                            if (line.trim() != "") {
                                const personIndex = areas[prevArea]['people'].findIndex(person => person.name === mover);
                                if (personIndex !== -1) {
                                    const person = areas[prevArea]['people'].splice(personIndex, 1)[0];
                                    areas[currentArea]['people'].push(person);
                                }
                            }
                        }
                    }
                }
            }
            
            updateImageGrid(currentArea);
        }

        function areaContext(area) {
            let context = " \n" + areas[area].name + " : " + areas[area].description + "\n\n";
            if(areas[area].people.length > 0)
            {
                context += "People nearby\n";
                for(let i = 0; i < areas[area].people.length; i++)
                {
                    context += areas[area].people[i].name + ": " + areas[area].people[i].description + "\n";
                }
                context += "\n";
            }
            if(areas[area].things.length > 0)
            {
                context += "Things in area\n";
                for(let i = 0; i < areas[area].things.length; i++)
                {
                    context += areas[area].things[i].name + ": " + areas[area].things[i].description + "\n";
                }
                context += "\n";
            }
            if(areas[area].hostiles.length > 0)
            {
                context += "Hostiles nearby\n";
                for(let i = 0; i < areas[area].hostiles.length; i++)
                {
                    context += areas[area].hostiles[i].name + ": " + areas[area].hostiles[i].description + "\n";
                }
                context += "\n";
            }
            return context;
        }

        async function setupStart() {
            await generateArea(settings.starting_area, settings.starting_area_description);
            document.getElementById('sceneart').src = URL.createObjectURL(areas[settings.starting_area].image);
            document.getElementById('sceneart').alt = areas[settings.starting_area].description;
            const responseElement = document.createElement('div');
            let text = await generateText(settings.story_param, settings.world_description + "\n" + "[Generate the beginning of the story as the player arrives at " + areas[settings.starting_area] + ", an area described as " + areas[settings.starting_area].description + ". Response should be less than 300 words.]");

            // Trim incomplete sentences from the end of the text
            const sentences = text.match(/[^.!?]+[.!?]+["']?/g);
            if (sentences && sentences.length > 1) {
                sentences.pop(); // Remove the last incomplete sentence
                text = sentences.join(' '); // Rejoin the sentences
            }

            responseElement.innerHTML = text.replace(/\n/g, '<br>');
            output.appendChild(responseElement);
            output.scrollTop = output.scrollHeight;                
            await outputCheck(text);
            updateImageGrid(settings.starting_area);
            areas[settings.starting_area].x = 100;
            areas[settings.starting_area].y = 100;

            addLocation(settings.starting_area);
            await generateArt(settings.player_visual, "", settings.player_seed).then(blob => {
                document.getElementById('playerart').src = URL.createObjectURL(blob);
            });
        }

        // Map dragging functionality
        let isDragging = false;
        let dragStartX, dragStartY;

        map.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX - map.offsetLeft;
            dragStartY = e.clientY - map.offsetTop;
            map.style.cursor = 'grabbing';
        });

        map.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const x = e.clientX - dragStartX;
                const y = e.clientY - dragStartY;
                map.style.left = `${x}px`;
                map.style.top = `${y}px`;
            }
        });

        map.addEventListener('mouseup', () => {
            isDragging = false;
            map.style.cursor = 'grab';
        });

        map.addEventListener('mouseleave', () => {
            isDragging = false;
            map.style.cursor = 'grab';
        });

        // Add locations to the map
        function addLocation(name) {
            const tooltip = document.getElementById('tooltip');
            const location = document.createElement('div');
            location.classList.add('location');
            location.style.left = `${areas[name].x}px`;
            location.style.top = `${areas[name].y}px`;
            location.style.width = '50px'; // Set the width of the square
            location.style.height = '50px'; // Set the height of the square
            location.style.backgroundImage = `url(${URL.createObjectURL(areas[name].image)})`; // Set the background image
            location.style.backgroundSize = 'cover'; // Ensure the image covers the square
            location.style.border = '1px solid #ccc'; // Optional: Add a border to the square
            location.addEventListener('click', (e) => {
                e.stopPropagation();
                openSubmenu(name, e.clientX, e.clientY);
            });
            location.addEventListener('mouseover', () => {
                tooltip.style.display = 'block';
                tooltip.innerHTML = `<strong>${name}</strong><br>${areas[name].description}<br><img src="${URL.createObjectURL(areas[name].image)}" alt="${name}" style="width: 100px; height: auto;">`;
            });
            location.addEventListener('mousemove', (e) => {
                tooltip.style.left = e.pageX + 10 + 'px';
                tooltip.style.top = e.pageY + 10 + 'px';
            });
            location.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
            map.appendChild(location);
        }

        // Open submenu for a location
        function openSubmenu(name, x, y) {
            submenu.innerHTML = `<strong>${name}</strong><br><button onclick="goToLocation('${name}')">Go</button>`;
            submenu.style.left = `${x}px`;
            submenu.style.top = `${y}px`;
            submenu.style.display = 'block';
        }

        // Close submenu when clicking outside
        document.addEventListener('click', () => {
            submenu.style.display = 'none';
        });

        // Go to a location
        function goToLocation(name) {
            currentArea = name;
            updateImageGrid(name);
            document.getElementById('sceneart').src = URL.createObjectURL(areas[name].image);
            document.getElementById('sceneart').alt = areas[name].description;
            submenu.style.display = 'none';
        }

        // Things are people, monsters, and interactables.
        // Should have name, seed, type, visual, description, level, affinity,
        // health, attack, defense, speed, magic, magic defense, skills, items, location, status effects

        let areas = {};
        let currentArea;
        loadSettings().then(() => {
            areas[settings.starting_area] = {};
            currentArea = settings.starting_area;
// setup disabled for quicker testing, re-enable for normal use.
//            setupStart();
        });

        function restartGame() {
            areas = {};
            areas[settings.starting_area] = {};
            currentArea = settings.starting_area;
            document.getElementById('output').innerHTML = '';
            document.getElementById('imageGrid').innerHTML = '';
            setupStart();
        }

    </script>
</body>
</html>